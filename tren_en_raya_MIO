# ===========================================================
# FUNCI√ìN: crear_tablero()
# Prop√≥sito: Inicializar un tablero vac√≠o de 3x3.
# Detalle:
#   - Usamos una "lista por comprensi√≥n" para crear 3 filas.
#   - Cada fila es una lista con 3 espacios en blanco (' '), 
#     que representan casillas vac√≠as.
#   - El tablero se estructura como una matriz (lista de listas).
# ===========================================================
def crear_tablero():
    return [[' ' for _ in range(3)] for _ in range(3)]


# ===========================================================
# FUNCI√ìN: mostrar_tablero(tablero)
# Prop√≥sito: Mostrar el estado actual del tablero en la consola.
# Detalle:
#   - Imprimimos encabezados para columnas (0, 1, 2) para guiar al usuario.
#   - Usamos enumerate() para obtener el √≠ndice (i) y el contenido (fila).
#   - join() une los elementos de la fila con " | " para el formato t√≠pico.
#   - Imprimimos l√≠neas divisorias ("---------") entre filas (solo 2 veces).
#   - El \n al inicio da un salto de l√≠nea para mejor legibilidad.
# ===========================================================
def mostrar_tablero(tablero):
    print("\n  0   1   2")  # Encabezado de columnas
    for i, fila in enumerate(tablero):
        print(f"{i} {' | '.join(fila)}")  # Muestra fila con √≠ndice
        if i < 2:  # Solo entre filas, no al final
            print("  ---------")


# ===========================================================
# FUNCI√ìN: movimiento_valido(tablero, fila, col)
# Prop√≥sito: Verificar si un movimiento es legal.
# Detalle:
#   - Primero: ¬øest√° dentro del rango [0, 2]?
#   - Segundo: ¬øla casilla est√° vac√≠a (' ')?
#   - Si ambas condiciones se cumplen ‚Üí movimiento v√°lido.
#   - Devuelve True o False.
# ===========================================================
def movimiento_valido(tablero, fila, col):
    if 0 <= fila <= 2 and 0 <= col <= 2:  # Dentro del tablero
        return tablero[fila][col] == ' '   # ¬øEst√° vac√≠a?
    return False  # Fuera de rango ‚Üí inv√°lido


# ===========================================================
# FUNCI√ìN: hacer_movimiento(tablero, fila, col, jugador)
# Prop√≥sito: Colocar la marca del jugador en una casilla.
# Detalle:
#   - Simplemente asigna el s√≠mbolo ('X' o 'O') a la posici√≥n dada.
#   - Supone que el movimiento ya fue validado (¬°no verifica aqu√≠!).
# ===========================================================
def hacer_movimiento(tablero, fila, col, jugador):
    tablero[fila][col] = jugador


# ===========================================================
# FUNCI√ìN: verificar_ganador(tablero, jugador)
# Prop√≥sito: Determinar si un jugador ha ganado.
# Detalle:
#   - Revisa las 3 filas: ¬øalguna tiene 3 marcas iguales del jugador?
#   - Revisa las 3 columnas: compara verticalmente.
#   - Revisa las 2 diagonales manualmente.
#   - Si encuentra una l√≠nea ganadora, devuelve True.
#   - Si no, devuelve False.
#   - Esta funci√≥n se llama despu√©s de cada movimiento.
# ===========================================================
def verificar_ganador(tablero, jugador):
    # --- Filas ---
    for fila in tablero:
        if fila == [jugador, jugador, jugador]:
            return True

    # --- Columnas ---
    for col in range(3):  # col = 0, 1, 2
        if tablero[0][col] == tablero[1][col] == tablero[2][col] == jugador:
            return True

    # --- Diagonal principal (de arriba-izquierda a abajo-derecha) ---
    if tablero[0][0] == tablero[1][1] == tablero[2][2] == jugador:
        return True

    # --- Diagonal secundaria (de arriba-derecha a abajo-izquierda) ---
    if tablero[0][2] == tablero[1][1] == tablero[2][0] == jugador:
        return True

    return False  # No hay l√≠nea ganadora


# ===========================================================
# FUNCI√ìN: tablero_lleno(tablero)
# Prop√≥sito: Detectar un empate.
# Detalle:
#   - Recorre cada fila.
#   - Si encuentra al menos un espacio vac√≠o (' '), el tablero NO est√° lleno.
#   - Si ninguna fila tiene ' ', entonces est√° lleno ‚Üí empate posible.
# ===========================================================
def tablero_lleno(tablero):
    for fila in tablero:
        if ' ' in fila:
            return False  # A√∫n hay casillas libres
    return True  # Todas las casillas est√°n ocupadas


# ===========================================================
# FUNCI√ìN: obtener_movimiento(jugador)
# Prop√≥sito: Pedir al usuario su jugada y validar el formato.
# Detalle:
#   - Usa un bucle while True para repetir hasta que la entrada sea v√°lida.
#   - input() captura lo que el usuario escribe.
#   - split() separa la entrada por espacios (ej: "1 2" ‚Üí ["1", "2"]).
#   - map(int, ...) convierte cada parte a entero.
#   - Si el usuario escribe algo inv√°lido (letras, un solo n√∫mero, etc.),
#     se lanza una excepci√≥n ValueError ‚Üí se captura y se pide de nuevo.
# ===========================================================
def obtener_movimiento(jugador):
    while True:
        try:
            entrada = input(f"Jugador {jugador}, ingresa fila y columna (ej: 1 2): ")
            fila, col = map(int, entrada.split())  # Convierte a enteros
            return fila, col  # Sale del bucle si todo va bien
        except ValueError:
            print("Entrada inv√°lida. Usa dos n√∫meros separados por un espacio (ej: 0 1).")


# ===========================================================
# FUNCI√ìN: cambiar_jugador(jugador)
# Prop√≥sito: Alternar entre 'X' y 'O' despu√©s de cada turno.
# Detalle:
#   - Si el jugador actual es 'X', devuelve 'O'.
#   - Si es 'O', devuelve 'X'.
#   - Simple y eficiente con un operador condicional.
# ===========================================================
def cambiar_jugador(jugador):
    return 'O' if jugador == 'X' else 'X'


# ===========================================================
# FUNCI√ìN: jugar()
# Prop√≥sito: Coordinar toda la l√≥gica del juego (funci√≥n principal).
# Detalle paso a paso:
#   1. Crea un tablero vac√≠o.
#   2. Define que empieza el jugador 'X'.
#   3. Muestra un mensaje de bienvenida.
#   4. Entra en un bucle infinito que solo termina con break.
#   5. En cada iteraci√≥n:
#        a. Muestra el tablero actual.
#        b. Pide al jugador actual que haga un movimiento.
#        c. Si el movimiento es v√°lido:
#             - Lo aplica al tablero.
#             - Verifica si ese movimiento hizo ganar al jugador.
#                 ‚Üí Si s√≠: muestra tablero, anuncia ganador y termina.
#             - Verifica si el tablero est√° lleno (empate).
#                 ‚Üí Si s√≠: muestra tablero, anuncia empate y termina.
#             - Cambia de turno.
#        d. Si el movimiento NO es v√°lido:
#             - Muestra mensaje de error y repite el turno.
# ===========================================================
def jugar():
    tablero = crear_tablero()      # Paso 1: tablero limpio
    jugador_actual = 'X'           # Paso 2: empieza X

    print("¬°Bienvenido al 3 en raya!")
    print("Las filas y columnas van de 0 a 2.")  # Gu√≠a para el usuario

    while True:  # Bucle principal del juego
        mostrar_tablero(tablero)
        fila, col = obtener_movimiento(jugador_actual)

        if movimiento_valido(tablero, fila, col):
            hacer_movimiento(tablero, fila, col, jugador_actual)

            # ¬øGan√≥ con este movimiento?
            if verificar_ganador(tablero, jugador_actual):
                mostrar_tablero(tablero)
                print(f"¬°Felicidades! El jugador {jugador_actual} ha ganado üéâ")
                break  # Termina el juego

            # ¬øEmpate?
            if tablero_lleno(tablero):
                mostrar_tablero(tablero)
                print("¬°Empate! ü§ù")
                break  # Termina el juego

            # Cambiar turno
            jugador_actual = cambiar_jugador(jugador_actual)

        else:
            print("Movimiento inv√°lido. La casilla est√° ocupada o fuera de rango. Intenta de nuevo.")


# ===========================================================
# BLOQUE DE EJECUCI√ìN PRINCIPAL
# Prop√≥sito: Ejecutar el juego solo si el script se corre directamente.
# Detalle:
#   - Esta es una buena pr√°ctica en Python.
#   - Permite que el archivo se importe como m√≥dulo sin ejecutar el juego.
# ===========================================================
if __name__ == "__main__":
    jugar()